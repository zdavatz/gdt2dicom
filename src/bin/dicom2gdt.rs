use clap::Parser;

use std::fs::create_dir_all;
use std::path::PathBuf;

use gdt2dicom::dcm_xml::{
    export_images_from_dcm_with_patient_id, parse_dcm_as_xml, DCMImageFormat,
};
use gdt2dicom::gdt::{dcm_xml_to_file, file_to_string};

/// Convert a gdt file and an image folder to a dicom file
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    #[arg(short, long)]
    dicom_file: PathBuf,

    /// Where to output the GDT file, omitted = stdout
    #[arg(short, long)]
    gdt_file: Option<PathBuf>,

    /// Where to output the PNG files
    #[arg(short, long)]
    pngs: Option<PathBuf>,
}

fn main() -> Result<(), std::io::Error> {
    let args = Args::parse();
    let events = parse_dcm_as_xml(&args.dicom_file).unwrap();
    let file = dcm_xml_to_file(&events);
    if let Some(pngs_path) = args.pngs {
        if !pngs_path.exists() {
            println!(
                "Path {} doesn't exist, creating directory...",
                pngs_path.display()
            );
            create_dir_all(&pngs_path)?;
            println!("Created {}", pngs_path.display());
        }
        if !pngs_path.is_dir() {
            println!(
                "{} is not a directory, not exporting png.",
                pngs_path.display()
            )
        } else {
            println!("Exporting images to {}", &pngs_path.display());
            export_images_from_dcm_with_patient_id(
                &args.dicom_file,
                &pngs_path,
                DCMImageFormat::Png,
                None,
            )
            .unwrap();
            println!("Exported images");
        }
    }
    let gdt_string = file_to_string(file);

    if let Some(path) = args.gdt_file {
        std::fs::write(&path, gdt_string)?;
        println!("GDT File written to:{}", path.display());
    } else {
        println!("GDT File:\r\n{}", &gdt_string);
    }

    return Ok(());
}
